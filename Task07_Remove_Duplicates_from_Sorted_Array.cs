using System;
using System.Linq;

public class Solution
{
    public int RemoveDuplicates(int[] nums)
    {
        int size = nums.Length;  // Размер исходного массива
        if (size == 0) return 0;  // Если массив пуст, возвращаем 0

        int[] newArr = new int[size];  // Новый массив для уникальных элементов
        int k = 0;  // Индекс для записи уникальных элементов в новый массив

        for (int i = 0; i < nums.Length; i++)
        {  // Проходим по всем элементам массива nums
            bool isDuplicate = false;  // Флаг для проверки на дубликаты

            // Проходим по уже найденным уникальным элементам
            for (int j = 0; j < k; j++)
            {  // Проверяем каждый новый элемент на дубликаты
                if (nums[i] == newArr[j])
                {  // Если текущий элемент уже есть в newArr
                    isDuplicate = true;  // Помечаем его как дубликат
                    break;  // Прерываем цикл
                }
            }

            // Если элемента нет среди уникальных, добавляем его
            if (!isDuplicate)
            {
                newArr[k] = nums[i];  // Записываем уникальный элемент в newArr
                k++;  // Увеличиваем индекс для следующего уникального элемента
            }
        }

        // Копируем уникальные элементы обратно в nums
        for (int i = 0; i < k; i++)
        {  // Копируем элементы из newArr обратно в nums
            nums[i] = newArr[i];
        }

        return k;  // Возвращаем количество уникальных элементов
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        // Тестируем метод с примером
        Solution solution = new Solution();

        // Исходный массив
        int[] nums = new int[] { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4 };

        // Выводим исходный массив
        Console.WriteLine("Исходный массив:");
        Console.WriteLine(string.Join(", ", nums));

        // Вызываем метод для удаления дубликатов
        int k = solution.RemoveDuplicates(nums);

        // Выводим результаты
        Console.WriteLine("\nМассив после удаления дубликатов:");
        Console.WriteLine(string.Join(", ", nums.Take(k)));  // Выводим только уникальные элементы

        Console.WriteLine("\nКоличество уникальных элементов: " + k);
    }
}

//Пояснение к коду:
//Метод RemoveDuplicates:

//Этот метод проходит по всем элементам массива nums и сохраняет уникальные элементы в массив newArr.
//Для каждого элемента он проверяет, не является ли он дубликатом, используя флаг isDuplicate. Если элемент уже есть в newArr, он пропускается.
//В конце копируем уникальные элементы обратно в исходный массив nums и возвращаем количество уникальных элементов.
//Программа Program:

//В методе Main создается массив nums, который будет протестирован.
//После вызова метода RemoveDuplicates, мы выводим результат — новый массив с уникальными элементами и их количество.
//Вывод в консоль:

//Мы выводим исходный массив, затем массив после удаления дубликатов и количество уникальных элементов.
//Пример вывода:
//Исходный массив:
//0, 0, 1, 1, 2, 2, 3, 3, 4, 4

//Массив после удаления дубликатов:
//0, 1, 2, 3, 4

//Количество уникальных элементов: 5

//Мы начинаем с того, что проходим по массиву, проверяем каждый элемент на наличие дубликатов среди уже добавленных в новый массив и в случае отсутствия дубликата добавляем элемент в новый массив.

//Исходные данные:
//Массив: nums = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]

//Размер массива: 10
//Новый массив newArr для уникальных элементов: инициализирован нулями, размер = 10
//Индекс k для записи уникальных элементов: изначально k = 0.
//Шаги алгоритма:
//Шаг 1: Первая итерация (i = 0)
//Текущий элемент: nums[0] = 0
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] (еще не заполнен уникальными значениями)
//Индекс k = 0
//Проверяем, есть ли элемент 0 в новом массиве newArr. Поскольку массив пуст, элемент 0 уникален.
//Добавляем 0 в newArr[0].
//Увеличиваем k на 1, теперь k = 1.
//Теперь новый массив выглядит так:
//newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 2: Вторая итерация (i = 1)
//Текущий элемент: nums[1] = 0
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 1
//Проверяем, есть ли элемент 0 в новом массиве. Мы видим, что элемент 0 уже есть в newArr[0].
//Поэтому, устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 3: Третья итерация (i = 2)
//Текущий элемент: nums[2] = 1
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 1
//Проверяем, есть ли элемент 1 в новом массиве. Он ещё не встречался.
//Добавляем 1 в newArr[1].
//Увеличиваем k на 1, теперь k = 2.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 4: Четвертая итерация (i = 3)
//Текущий элемент: nums[3] = 1
//Новый массив: newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 2
//Проверяем, есть ли элемент 1 в новом массиве. Мы видим, что элемент 1 уже есть в newArr[1].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 5: Пятая итерация (i = 4)
//Текущий элемент: nums[4] = 2
//Новый массив: newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 2
//Проверяем, есть ли элемент 2 в новом массиве. Он ещё не встречался.
//Добавляем 2 в newArr[2].
//Увеличиваем k на 1, теперь k = 3.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]

//Шаг 6: Шестая итерация (i = 5)
//Текущий элемент: nums[5] = 2
//Новый массив: newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 3
//Проверяем, есть ли элемент 2 в новом массиве. Мы видим, что элемент 2 уже есть в newArr[2].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]

//Шаг 7: Седьмая итерация (i = 6)
//Текущий элемент: nums[6] = 3
//Новый массив: newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 3
//Проверяем, есть ли элемент 3 в новом массиве. Он ещё не встречался.
//Добавляем 3 в newArr[3].
//Увеличиваем k на 1, теперь k = 4.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]

//Шаг 8: Восьмая итерация (i = 7)
//Текущий элемент: nums[7] = 3
//Новый массив: newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]
//Индекс k = 4
//Проверяем, есть ли элемент 3 в новом массиве. Мы видим, что элемент 3 уже есть в newArr[3].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]

//Шаг 9: Девятая итерация (i = 8)
//Текущий элемент: nums[8] = 4
//Новый массив: newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]
//Индекс k = 4
//Проверяем, есть ли элемент 4 в новом массиве. Он ещё не встречался.
//Добавляем 4 в newArr[4].
//Увеличиваем k на 1, теперь k = 5.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]Мы начинаем с того, что проходим по массиву, проверяем каждый элемент на наличие дубликатов среди уже добавленных в новый массив и в случае отсутствия дубликата добавляем элемент в новый массив.

//Исходные данные:
//Массив: nums = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]

//Размер массива: 10
//Новый массив newArr для уникальных элементов: инициализирован нулями, размер = 10
//Индекс k для записи уникальных элементов: изначально k = 0.
//Шаги алгоритма:
//Шаг 1: Первая итерация (i = 0)
//Текущий элемент: nums[0] = 0
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] (еще не заполнен уникальными значениями)
//Индекс k = 0
//Проверяем, есть ли элемент 0 в новом массиве newArr. Поскольку массив пуст, элемент 0 уникален.
//Добавляем 0 в newArr[0].
//Увеличиваем k на 1, теперь k = 1.
//Теперь новый массив выглядит так:
//newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 2: Вторая итерация (i = 1)
//Текущий элемент: nums[1] = 0
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 1
//Проверяем, есть ли элемент 0 в новом массиве. Мы видим, что элемент 0 уже есть в newArr[0].
//Поэтому, устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 3: Третья итерация (i = 2)
//Текущий элемент: nums[2] = 1
//Новый массив: newArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 1
//Проверяем, есть ли элемент 1 в новом массиве. Он ещё не встречался.
//Добавляем 1 в newArr[1].
//Увеличиваем k на 1, теперь k = 2.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 4: Четвертая итерация (i = 3)
//Текущий элемент: nums[3] = 1
//Новый массив: newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 2
//Проверяем, есть ли элемент 1 в новом массиве. Мы видим, что элемент 1 уже есть в newArr[1].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]

//Шаг 5: Пятая итерация (i = 4)
//Текущий элемент: nums[4] = 2
//Новый массив: newArr = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 2
//Проверяем, есть ли элемент 2 в новом массиве. Он ещё не встречался.
//Добавляем 2 в newArr[2].
//Увеличиваем k на 1, теперь k = 3.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]

//Шаг 6: Шестая итерация (i = 5)
//Текущий элемент: nums[5] = 2
//Новый массив: newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 3
//Проверяем, есть ли элемент 2 в новом массиве. Мы видим, что элемент 2 уже есть в newArr[2].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]

//Шаг 7: Седьмая итерация (i = 6)
//Текущий элемент: nums[6] = 3
//Новый массив: newArr = [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]
//Индекс k = 3
//Проверяем, есть ли элемент 3 в новом массиве. Он ещё не встречался.
//Добавляем 3 в newArr[3].
//Увеличиваем k на 1, теперь k = 4.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]

//Шаг 8: Восьмая итерация (i = 7)
//Текущий элемент: nums[7] = 3
//Новый массив: newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]
//Индекс k = 4
//Проверяем, есть ли элемент 3 в новом массиве. Мы видим, что элемент 3 уже есть в newArr[3].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]

//Шаг 9: Девятая итерация (i = 8)
//Текущий элемент: nums[8] = 4
//Новый массив: newArr = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0]
//Индекс k = 4
//Проверяем, есть ли элемент 4 в новом массиве. Он ещё не встречался.
//Добавляем 4 в newArr[4].
//Увеличиваем k на 1, теперь k = 5.
//Теперь новый массив выглядит так:
//newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]


//Шаг 10: Десятая итерация (i = 9)
//Текущий элемент: nums[9] = 4
//Новый массив: newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]
//Индекс k = 5
//Проверяем, есть ли элемент 4 в новом массиве. Мы видим, что элемент 4 уже есть в newArr[4].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]
//Копирование в исходный массив:
//После всех шагов, в массиве newArr находятся уникальные элементы на первых 5 позициях:
//newArr = [0, 1, 2, 3, 4, _, _, _, _, _]
//Теперь мы копируем элементы из newArr обратно в nums:
//nums = [0, 1, 2, 3, 4, _, _, _, _, _]
//Результат:
//Возвращаемое значение: k = 5 (количество уникальных элементов).
//Итоговый массив nums будет: [0, 1, 2, 3, 4, _, _, _, _, _].Шаг 10: Десятая итерация (i = 9)
//Текущий элемент: nums[9] = 4
//Новый массив: newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]
//Индекс k = 5
//Проверяем, есть ли элемент 4 в новом массиве. Мы видим, что элемент 4 уже есть в newArr[4].
//Устанавливаем флаг isDuplicate = true, пропускаем этот элемент.
//Индекс k не меняется.
//Теперь новый массив остаётся таким же:
//newArr = [0, 1, 2, 3, 4, 0, 0, 0, 0, 0]
//Копирование в исходный массив:
//После всех шагов, в массиве newArr находятся уникальные элементы на первых 5 позициях:
//newArr = [0, 1, 2, 3, 4, _, _, _, _, _]
//Теперь мы копируем элементы из newArr обратно в nums:
//nums = [0, 1, 2, 3, 4, _, _, _, _, _]
//Результат:
//Возвращаемое значение: k = 5 (количество уникальных элементов).
//Итоговый массив nums будет: [0, 1, 2, 3, 4, _, _, _, _, _].


//Добавдена проверка if (size == 0) return 0;, чтобы избежать ошибок на пустых массивах.
//Логика обработки массива осталась прежней, но теперь алгоритм правильно воспринимает ноль 
//как уникальный элемент.
//Нужно учесть, что первая встреча нуля должна считаться уникальной, 
//и для этого вложенный цикл должен пропускать элементы, которые уже были добавлены в новый массив.
//Если первый элемент равен 0, то он будет добавлен как уникальный элемент, 
//даже если этот элемент встречается несколько раз. Иначе говоря, 
//алгоритм должен просто пропустить первый дубликат нуляДобавдена проверка if (size == 0) return 0;, 
//чтобы избежать ошибок на пустых массивах.
//Логика обработки массива осталась прежней, но теперь алгоритм правильно воспринимает 
//ноль как уникальный элемент.
//Нужно учесть, что первая встреча нуля должна считаться уникальной, и для этого 
//вложенный цикл должен пропускать элементы, которые уже были добавлены в новый массив.
//Если первый элемент равен 0, то он будет добавлен как уникальный элемент, даже 
//если этот элемент встречается несколько раз. Иначе говоря, алгоритм должен 
//просто пропустить первый дубликат нуля